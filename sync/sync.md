# sync

## select

如果前面的表达式都阻塞了，那么默认分支就会被选中并执行
如果没有加入默认分支，一旦所有 case 表达式都不满足条件，select 语句就会被阻塞。直到至少有一个表达式满足条件为止

## chan

对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的
发送操作和接收操作中对元素值的处理都是不可分割的
发送操作在完全完成之前会被阻塞。接收操作也是如此

对于值为 nil 的通道，对它的发送操作和接收操作都会永久地处于阻塞状态
通道一旦关闭，再对它进行发送操作，就会引发 panic
关闭一个已经关闭了的通道，会引发 panic
接收操作可以感知到通道的关闭，并能够安全退出

## Mutex

Mutex 是一个结构体类型，属于值类型中的一种。mutex 数据传给一个函数、从函数中返回、赋给其他变量、进入通道都会导致它的副本的产生。原值和副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁

## Cond

条件变量的 Wait 方法

1. 将当前的 goroutine 加入到当前条件变量的通知队列中
2. 解锁当前的条件变量基于的那个互斥锁
3. 让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，当前 goroutine 处于阻塞状态
4. 如果通知到来并且决定唤醒这个 goroutine，那么在唤醒它之后重新锁定当前条件变量基于的互斥锁。然后，当前的 goroutine 就会继续执行

当有多个 goroutine 在等待共享资源时，每次成功的 goroutine 只有一个。条件变量的 Wait 方法会在当前的 goroutine 醒来后先重新锁定互斥锁。在成功的 goroutine 最终解锁互斥锁之后，其他的 goroutine 会先后进入临界区，此时共享资源的状态已经不满足要求了，保险起见，就需要再次检查，那些未被满足的 goroutine 显然还需要继续等待和检查

条件变量的 Signal 方法和 Broadcast 方法

1. Signal 方法的通知只会唤醒一个因此而等待的 goroutine
2. Broadcast 方法的通知却会唤醒所有为此等待的 goroutine
3. Wait 方法把当前的 goroutine 添加到通知队列的队尾，Signal 方法从通知队列的队首开始，查找可被唤醒的 goroutine
4. 与 Wait 方法不同，Signal 方法和 Broadcast 方法并不需要在互斥锁的保护下执行
