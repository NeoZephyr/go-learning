# sync

## select

如果前面的表达式都阻塞了，那么默认分支就会被选中并执行
如果没有加入默认分支，一旦所有 case 表达式都不满足条件，select 语句就会被阻塞。直到至少有一个表达式满足条件为止

## chan

对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的
发送操作和接收操作中对元素值的处理都是不可分割的
发送操作在完全完成之前会被阻塞。接收操作也是如此

对于值为 nil 的通道，对它的发送操作和接收操作都会永久地处于阻塞状态
通道一旦关闭，再对它进行发送操作，就会引发 panic
关闭一个已经关闭了的通道，会引发 panic
接收操作可以感知到通道的关闭，并能够安全退出

## Mutex

Mutex 是一个结构体类型，属于值类型中的一种。mutex 数据传给一个函数、从函数中返回、赋给其他变量、进入通道都会导致它的副本的产生。原值和副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁

## Cond

条件变量的 Wait 方法

1. 将当前的 goroutine 加入到当前条件变量的通知队列中
2. 解锁当前的条件变量基于的那个互斥锁
3. 让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，当前 goroutine 处于阻塞状态
4. 如果通知到来并且决定唤醒这个 goroutine，那么在唤醒它之后重新锁定当前条件变量基于的互斥锁。然后，当前的 goroutine 就会继续执行

当有多个 goroutine 在等待共享资源时，每次成功的 goroutine 只有一个。条件变量的 Wait 方法会在当前的 goroutine 醒来后先重新锁定互斥锁。在成功的 goroutine 最终解锁互斥锁之后，其他的 goroutine 会先后进入临界区，此时共享资源的状态已经不满足要求了，保险起见，就需要再次检查，那些未被满足的 goroutine 显然还需要继续等待和检查

条件变量的 Signal 方法和 Broadcast 方法

1. Signal 方法的通知只会唤醒一个因此而等待的 goroutine
2. Broadcast 方法的通知却会唤醒所有为此等待的 goroutine
3. Wait 方法把当前的 goroutine 添加到通知队列的队尾，Signal 方法从通知队列的队首开始，查找可被唤醒的 goroutine
4. 与 Wait 方法不同，Signal 方法和 Broadcast 方法并不需要在互斥锁的保护下执行

## atomic

atomic 包中的函数可以做的原子操作有：加法、比较并交换、加载、存储和交换

## WaitGroup

## Once

## Pool

### 对象池

sync 包中还有一个包级私有的全局变量，类型为 *sync.Pool 的切片，代表当前的程序中使用的所有临时对象池的汇总，称之为池汇总列表。通常，在一个临时对象池的 Put 方法或 Get 方法第一次被调用的时候，这个池就会被添加到池汇总列表中

在临时对象池中，有一个多层的数据结构。这个数据结构的顶层为本地池列表，这个列表的长度，总是与调度器中的 P 的数量相同。在本地池列表中的每个本地池都包含了三个字段，它们是：存储私有临时对象的字段 private、代表了共享临时对象列表的字段 shared，以及一个 sync.Mutex 类型的嵌入字段

每个本地池都对应着一个 P，在程序调用临时对象池的 Put 方法或 Get 方法的时候，总会先试图从该临时对象池的本地池列表中，获取与之对应的本地池，依据的就是与当前的 goroutine 关联的那个 P 的 ID

### Get

临时对象池的 Get 方法，总会先试图从对应的本地池的 private 字段处获取一个临时对象。只有当这个 private 字段的值为 nil 时，它才会去访问本地池的 shared 字段。在互斥锁的保护下，试图把该共享临时对象列表中的最后一个元素值取出并作为结果

这里的共享临时对象列表也可能是空的，这可能是由于这个本地池中的所有临时对象都已经被取走了，也可能是当前的临时对象池刚被清理过。Get 方法会去访问当前的临时对象池中的所有本地池，然后逐个搜索它们的共享临时对象列表。只要发现某个共享临时对象列表中包含元素值，它就会把该列表的最后一个元素值取出并作为结果返回

即使这样也可能无法拿到一个可用的临时对象，比如，在所有的临时对象池都刚被大清洗的情况下就会是如此。这时，Get 方法就会调用可创建临时对象的那个函数。这个函数是由临时对象池的 New 字段代表的，并且需要我们在初始化临时对象池的时候给定。如果这个字段的值是 nil，那么 Get 方法此时也只能返回 nil

### Put

临时对象池的 Put 方法总会先试图把新的临时对象，存储到对应的本地池的 private 字段中，以便在后面获取临时对象的时候，可以快速地拿到一个可用的值。只有当这个 private 字段已经存有某个值时，该方法才会去访问本地池的 shared 字段当。由于 shared 字段是共享的，所以此时必须受到互斥锁的保护。Put 方法会在互斥锁的保护下，把新的临时对象追加到共享临时对象列表的末尾

### 池清理函数

sync 包在被初始化的时候，会向 Go 语言运行时系统注册池清理函数，之后每次即将执行垃圾回收时就都会执行该函数

池清理函数会遍历池汇总列表。对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都置为 nil，然后再把这个池中的所有本地池列表都销毁掉。最后，池清理函数会把池汇总列表重置为空的切片。如果临时对象池以外的代码再无对它们的引用，那么在稍后的垃圾回收过程中，这些临时对象就会被当作垃圾销毁掉

## Map
